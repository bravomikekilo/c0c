## 加法操作符
文法定义: ＜加法运算符＞ ::= +｜-

项之间的操作符 + 和 -, 存在隐式类型转换, 结果类型是操作数的类型中较大的那个
实例
```
int a, b;
char c;
char d;
a + b // 结果类型是 int
a + c // 结果类型是 int
```



## 乘法运算符
文法定义: ＜乘法运算符＞  ::= *｜/

因子之间的操作符 * 和 / 存在隐式类型转换, 结果类型是操作数的类型中较大的那个
实例

```
int a, b;
char c;
a * b // 结果类型是 int
a * c // 结果类型是 int
c * c // 结果类型是 char
```


## 关系运算符
文法定义 ＜关系运算符＞  ::=  <｜<=｜>｜>=｜!=｜==

用在条件中,用来进行比较两个数产生逻辑值的操作符.


< 小于

\> 大于


<= 小于等于


\>= 大于等于

!= 不等于

== 等于

示例

```
1 + 2 > 3
a != b
c >= d
'a' < 'b'
```

## 字母
＜字母＞   ::= ＿｜a｜．．．｜z｜A｜．．．｜Z

字母 除了大小写的英文字母以外,还有下划线

## 数字
＜数字＞   ::= ０｜＜非零数字＞
数字 0-9的10个数字

## 非零数字
＜非零数字＞  ::= １｜．．．｜９
非零数字 1-9的9个数字

## 字符
＜字符＞    ::=  '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'
字符字面量
可以使用的字符包括 + - * / 字母 _ 和 10个数字

## 字符串
＜字符串＞   ::=  "{十进制编码为32,33,35-126的ASCII字符}"
用"包围的字符的ascii字符的序列.

## 程序
＜程序＞    ::= {＜常量说明＞}{＜变量说明＞}{＜有返回值函数定义＞|＜无返回值函数定义＞}＜主函数＞

起始符号. 整个程序应该由这个符号推导出来.

## 常量说明
＜常量说明＞ ::=  const＜常量定义＞;{ const＜常量定义＞;}

## 常量定义
＜常量定义＞   ::=   int＜标识符＞＝＜整数＞{,＜标识符＞＝＜整数＞}
                            | char＜标识符＞＝＜字符＞{,＜标识符＞＝＜字符＞}

## 无符号整数
＜无符号整数＞  ::= ＜非零数字＞｛＜数字＞｝｜０

无符号整数字面量.

限制
1. 不能有前导0;
2. 不能大于INT_MAX，否则会发生整数溢出

示例
```
0
1
123
8898423
```


## 整数
＜整数＞        ::= ［＋｜－］＜无符号整数＞

有符号整数

限制
1. 不能有前导0
2. 不能大于INT_MAX或小于INT_MIN,否则会发生整数溢出.

示例
```
0
-0
1
+123
-8898
```


## 标识符
＜标识符＞    ::=  ＜字母＞｛＜字母＞｜＜数字＞｝

标识符 用来说明变量,常量或函数的名称,由下划线或字母开头,后接任意个下划线或数字或字母.

限制:
1. 同一作用域内不能出现重名
2. 第一个字符不能是数字

示例
```
abc
def
a2
def_use
use_def
_private_int_1
```

## 变量头部
＜声明头部＞   ::=  int＜标识符＞|char＜标识符＞

有返回值函数的声明头部 声明函数的返回值和函数名

限制: 函数不能出现重复定义,标识符的函数名不能和其他函数名和全局的变量和常量重名.

示例
```
int addOne
int add
int mul
```

## 变量说明
＜变量说明＞  ::= ＜变量定义＞;{＜变量定义＞;}

全局或函数的变量名的声明;

限制:
1. 所有的变量必须集中声明,常量和变量,函数定义或函数体之间不能互相穿插.
2. 同一作用域的变量和常量不能出现重名，全局变量和常量和函数之间不能重名.

示例
```
int a, b, c;
char x, y, z;
```

## 变量定义
＜变量定义＞  ::= ＜类型标识符＞(＜标识符＞|＜标识符＞'['＜无符号整数＞']'){,(＜标识符＞|＜标识符＞'['＜无符号整数＞']') } //＜无符号整数＞表示数组元素的个数，其值需大于0

## 类型标识符
＜类型标识符＞      ::=  int | char

## 有返回值函数定义
＜有返回值函数定义＞  ::=  ＜声明头部＞'('＜参数表＞')' '{'＜复合语句＞'}'

定义一个有返回值的函数,函数名和返回类型在声明头部中,形式参数在参数表中定义,最后的复合语句定义
函数中的局部变量,常量和函数体.

具体限制,函数不能出现重复定义,一个函数名只能定义一个函数,同时函数名不能和已经定义的变量名和常量名相同.
复合语句所包含的函数体中,在所有的执行路径上必须有返回语句,返回语句的类型必须和声明头部的返回类型匹配,否则会发生隐式转换.

示例

int addOne(int x) {
    int ret;
    ret = x + 1;
    return (ret);
}

## 无返回值函数定义
＜无返回值函数定义＞  ::= void＜标识符＞'('＜参数表＞')''{'＜复合语句＞'}'

定义一个无返回值的函数,函数名是标识符,形式参数在参数表中定义.最后的复合语句定义
函数中的局部变量,常量和函数体.

具体限制,函数不能出现重复定义,一个函数名只能定义一个函数,同时函数名不能和已经定义的变量名和常量名相同.

## 复合语句
＜复合语句＞   ::=  ［＜常量说明＞］［＜变量说明＞］＜语句列＞

作为函数定义的语句

包含了函数的局部常量,局部变量和函数体.
在函数的作用域中,函数内部定义的局部变量和局部常量的名称可以覆盖全局变量,常量和函数的名称.


## 参数表
＜参数表＞    ::=  ＜类型标识符＞＜标识符＞{,＜类型标识符＞＜标识符＞}| ＜空＞
函数定义的形式参数表, 定义了参数的名称和类型, 可以为空.

## 主函数
＜主函数＞    ::= void main'('')' '{'＜复合语句＞'}'

主函数的定义 主函数是程序的入口函数,是一个无参数无返回值的函数.

## 表达式
＜表达式＞    ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}   //[+|-]只作用于第一个<项>
表达式是

## 项
＜项＞     ::= ＜因子＞{＜乘法运算符＞＜因子＞}

## 因子
＜因子＞    ::= ＜标识符＞｜＜标识符＞'['＜表达式＞']'｜＜整数＞|＜字符＞｜＜有返回值函数调用语句＞|'('＜表达式＞')'

## 语句
＜语句＞    ::= ＜条件语句＞｜＜循环语句＞| '{'＜语句列＞'}'｜＜有返回值函数调用语句＞;
                      |＜无返回值函数调用语句＞;｜＜赋值语句＞;｜＜读语句＞;｜＜写语句＞;｜＜空＞;｜＜返回语句＞;

语句包含多种语句 条件语句,循环语句,赋值语句,读语句,写语句见单独的说明.

### {}包围的块语句,
多个语句 顺序执行

### 有返回值的函数调用语句;
调用函数并忽略返回值

### 无返回值函数调用语句;
调用函数

## 赋值语句
＜赋值语句＞   ::=  ＜标识符＞＝＜表达式＞|＜标识符＞'['＜表达式＞']'=＜表达式＞

### ＜标识符＞＝＜表达式＞
先计算右侧表达式,将表达式的值赋给左侧的变量.

限制
1. 左侧的标识符必须已经声明,并且是一个变量.
2. 如果标识符的声明的类型和表达式结果类型不同,将会发生隐式转换.

### ＜标识符＞'['＜表达式＞']'=＜表达式＞
先计算右侧表达式.再计算出数组下标,将右侧的值赋给左侧数组对应下标的变量.

限制
1. 左侧的标识符必须已经声明.
2. 左侧标识符必须是一个数组变量.
2. 如果标识符的声明的类型和表达式结果类型不同,将会发生隐式转换.



## 条件语句
＜条件语句＞  ::=  if '('＜条件＞')'＜语句＞[else＜语句＞]

如果条件为真,则执行if后的语句,如果条件为假且存在else子句,则执行else后的语句.

示例
```
if(a > 2) {
    print("a > 2");
} else {
    print("a < 2");
}

if(x + y == 3) {
    x = x + 2;
}

```


## 条件
＜条件＞    ::=  ＜表达式＞＜关系运算符＞＜表达式＞｜＜表达式＞ //表达式为0条件为假，否则为真
条件, 产生条件语句的逻辑值
1. 通过关系操作符比较两个表达式的值来得出结果
2. 只有单个表达式的情况,如果表达式为0则为假,否则为真.

## 循环语句
＜循环语句＞   ::=  do＜语句＞while '('＜条件＞')' |for'('＜标识符＞＝＜表达式＞;＜条件＞;＜标识符＞＝＜标识符＞(+|-)＜步长＞')'＜语句＞

### do while

先执行do内部的循环体,再判断while后的条件,如果条件满足,将从头开始下一个循环.
如果条件不满足,将跳出循环.


### for

执行第一个赋值语句,开始循环.
如果条件为假,跳出循环.
执行循环体,根据步长更新变量值.

限制
1. 计数变量必须是提前声明的整数或字符型变量.

示例
```
for(int i = 0; i < 10; i = i + 1) {
    printf(i);
}
```


## 步长
＜步长＞::= ＜无符号整数＞

步长,用于for循环的自增和自减,限制是数值不能超过32位无符号整数。

示例
```
100
120
```

## 有返回值函数调用语句
＜有返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'

调用一个有返回值的参数,实际参数是值参数表中的表达式,结果值的类型是有返回值函数的返回类型

约束: 不能调用未定义的函数,函数参数的类型必须和函数定义相匹配,否则会发生隐式转换.

示例
```

int addOne(int x) {
    return(x + 1);
}

int add(int x, int y) {
    return(x + y);
}



addOne(1);
add(1, 2);
add(1 + 3, 3 * 4);
```

## 无返回值函数调用语句
＜无返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'

调用一个无返回值的参数,实际参数是值参数表中的表达式,没有结果值,所以不能作为因子

约束: 不能调用未定义的函数,函数参数的类型必须和函数定义相匹配,否则会发生隐式转换.

示例
```

void show(int x) {
    printf("result");
    printf(x);
    return;
}


show(1 + 2 + 3);

```


## 值参数表
＜值参数表＞   ::= ＜表达式＞{,＜表达式＞}｜＜空＞
值参数表,函数调用的实际参数,由一个或多个逗号分割的表达式组成.



## 语句列
＜语句列＞   ::=｛＜语句＞｝
语句列,由0个或多个语句组成

## 读语句
＜读语句＞    ::=  scanf '('＜标识符＞{,＜标识符＞}')'
读语句,从输入文件读入一个或多个值，分别赋给标识符代表的变量.
语句列,由0个或多个语句组成

## 写语句
＜写语句＞    ::=  printf'('＜字符串＞,＜表达式＞')'|printf '('＜字符串＞')'|printf '('＜表达式＞')'

写语句 向输出文件中输出字符串或值.
语句中的字符串将会原样输出.char型值将会按字符输出,int型将会按数字输出.
需要注意的是每次输出完成后会自动附加一个换行符.

## 返回语句
＜返回语句＞   ::=  return['('＜表达式＞')']

返回语句 从函数中返回,返回值是表达式的值.
无返回值的函数的return语句没有后面的括号和表达式.

限制
1. 无返回值的函数的return语句没有括号和表达式.
2. 返回的表达式的类型如果和函数的返回类型不同,将会发生隐式转换.

示例
```
int addOne(int x) {
    return(x + 1);
}

void show(int x) {
    printf(x + 1);
    return;
}

```